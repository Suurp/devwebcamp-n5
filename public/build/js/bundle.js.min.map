{"version":3,"sources":["horas.js","ponentes.js","tags.js"],"names":["document","querySelector","busqueda","categoria_id","dia","categoria","dias","querySelectorAll","inputHiddenDia","inputHiddenHora","seleccionarHora","e","horaPrevia","classList","remove","target","add","value","dataset","horaId","obtenerHorasDisponibles","eventos","listadoHoras","forEach","li","hora","removeEventListener","horasTomadas","map","evento","hora_id","Array","from","filter","includes","addEventListener","buscarEventos","async","url","resultado","fetch","json","terminoBusqueda","name","Object","values","ponentesInput","ponenteHidden","seleccionarPonente","textContent","ponente","ponentePrevio","ponenteId","buscarPonentes","length","expresion","RegExp","normalize","replace","ponentesFiltrados","ponentes","ponenteNombre","nombre","toLowerCase","test","listadoPonentes","innerHTML","ponenteHTML","createElement","id","appendChild","noResultados","mostrarPonentes","obtenerPonentes","respuesta","arrayPonentes","apellido","formatearPonentes","error","console","tagsInput","tagsDiv","tagsInputHidden","tags","mostrarTags","tag","etiqueta","ondblclick","eliminarTag","ontouchend","actualizarInputHidden","join","tagToRemove","split","key","trim","preventDefault","newTag"],"mappings":"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","file":"bundle.js","sourcesContent":["(() => {\r\n\tconst horas = document.querySelector(\"#horas\");\r\n\r\n\tif (horas) {\r\n\t\tlet busqueda = {\r\n\t\t\tcategoria_id: \"\",\r\n\t\t\tdia: \"\",\r\n\t\t};\r\n\r\n\t\tconst categoria = document.querySelector(\"#categoria\");\r\n\t\tconst dias = document.querySelectorAll('[name=\"dia\"]');\r\n\t\tconst inputHiddenDia = document.querySelector('[name=\"dia_id\"]');\r\n\t\tconst inputHiddenHora = document.querySelector('[name=\"hora_id\"]');\r\n\r\n\t\tconst seleccionarHora = (e) => {\r\n\t\t\tconst horaPrevia = document.querySelector(\r\n\t\t\t\t\".horas__hora--seleccionada\"\r\n\t\t\t);\r\n\r\n\t\t\tif (horaPrevia) {\r\n\t\t\t\thoraPrevia.classList.remove(\"horas__hora--seleccionada\");\r\n\t\t\t}\r\n\r\n\t\t\t// Agregar clase de seleccionado\r\n\t\t\te.target.classList.add(\"horas__hora--seleccionada\");\r\n\r\n\t\t\tinputHiddenHora.value = e.target.dataset.horaId;\r\n\r\n\t\t\t// Llenar campo oculto de dia\r\n\t\t\tinputHiddenDia.value = document.querySelector(\r\n\t\t\t\t'[name=\"dia\"]:checked'\r\n\t\t\t).value;\r\n\t\t};\r\n\r\n\t\tconst obtenerHorasDisponibles = (eventos) => {\r\n\t\t\t//Reiniciar las horas\r\n\t\t\tconst listadoHoras = document.querySelectorAll(\"#horas li\");\r\n\t\t\tlistadoHoras.forEach((li) =>\r\n\t\t\t\tli.classList.add(\"horas__hora--deshabilitada\")\r\n\t\t\t);\r\n            \r\n            const horasDeshabilitadas = document.querySelectorAll(\"#horas li\");\r\n\t\t\thorasDeshabilitadas.forEach((hora) =>\r\n\t\t\t\thora.removeEventListener(\"click\", seleccionarHora)\r\n\t\t\t);\r\n\r\n\t\t\t// Comprobar eventos ya tomados y quitar la variable de deshabilitado\r\n\t\t\tconst horasTomadas = eventos.map((evento) => evento.hora_id);\r\n\r\n\t\t\tconst listadoHorasArray = Array.from(listadoHoras);\r\n\r\n\t\t\tconst resultado = listadoHorasArray.filter(\r\n\t\t\t\t(li) => !horasTomadas.includes(li.dataset.horaId)\r\n\t\t\t);\r\n\t\t\tresultado.forEach((li) =>\r\n\t\t\t\tli.classList.remove(\"horas__hora--deshabilitada\")\r\n\t\t\t);\r\n\r\n\t\t\tconst horasDisponibles = document.querySelectorAll(\r\n\t\t\t\t\"#horas li:not(.horas__hora--deshabilitada)\"\r\n\t\t\t);\r\n\t\t\thorasDisponibles.forEach((hora) => {\r\n\t\t\t\thora.addEventListener(\"click\", seleccionarHora);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tconst buscarEventos = async () => {\r\n\t\t\tconst { dia, categoria_id } = busqueda;\r\n\r\n\t\t\tconst url = `/api/eventos-horario?dia_id=${dia}&categoria_id=${categoria_id}`;\r\n\r\n\t\t\tconst resultado = await fetch(url);\r\n\t\t\tconst eventos = await resultado.json();\r\n\r\n\t\t\tobtenerHorasDisponibles(eventos);\r\n\t\t};\r\n\r\n\t\tconst terminoBusqueda = (e) => {\r\n\t\t\tbusqueda[e.target.name] = e.target.value;\r\n\r\n\t\t\t// Reiniciar los campos ocultos y el selector de horas\r\n\t\t\tinputHiddenHora.value = \"\";\r\n\t\t\tinputHiddenDia.value = \"\";\r\n\r\n\t\t\tconst horaPrevia = document.querySelector(\r\n\t\t\t\t\".horas__hora--seleccionada\"\r\n\t\t\t);\r\n\r\n\t\t\tif (horaPrevia) {\r\n\t\t\t\thoraPrevia.classList.remove(\"horas__hora--seleccionada\");\r\n\t\t\t}\r\n\r\n\t\t\tif (Object.values(busqueda).includes(\"\")) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tbuscarEventos();\r\n\t\t};\r\n\r\n\t\tcategoria.addEventListener(\"change\", terminoBusqueda);\r\n\r\n\t\tdias.forEach((dia) => {\r\n\t\t\tdia.addEventListener(\"change\", terminoBusqueda);\r\n\t\t});\r\n\t}\r\n})();\r\n","(() => {\r\n\t// Referencias a elementos del DOM\r\n\tconst ponentesInput = document.querySelector(\"#ponentes\");\r\n\tconst ponenteHidden = document.querySelector('[name=\"ponente_id\"]');\r\n\r\n\t/**\r\n\t * Maneja la selección de un ponente en la lista.\r\n\t * @param {Event} e - El evento de clic en un ponente.\r\n\t */\r\n\tconst seleccionarPonente = (e) => {\r\n\t\t// Establece el valor del input con el nombre del ponente seleccionado\r\n\t\tponentesInput.value = e.target.textContent;\r\n\t\tconst ponente = e.target;\r\n\r\n\t\t// Remueve la clase de selección previa\r\n\t\tconst ponentePrevio = document.querySelector(\r\n\t\t\t\".listado-ponentes__ponente--seleccionado\"\r\n\t\t);\r\n\t\tif (ponentePrevio) {\r\n\t\t\tponentePrevio.classList.remove(\r\n\t\t\t\t\"listado-ponentes__ponente--seleccionado\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Añade la clase de seleccionado al nuevo ponente y actualiza el valor oculto\r\n\t\tponente.classList.add(\"listado-ponentes__ponente--seleccionado\");\r\n\t\tponenteHidden.value = ponente.dataset.ponenteId;\r\n\t};\r\n\r\n\t/**\r\n\t * Muestra los ponentes filtrados en la lista.\r\n\t */\r\n\tconst mostrarPonentes = () => {\r\n\t\tconst listadoPonentes = document.querySelector(\"#listado-ponentes\");\r\n\t\tlistadoPonentes.innerHTML = \"\"; // Limpiar lista de ponentes\r\n\r\n\t\tif (ponentesFiltrados.length > 0) {\r\n\t\t\t// Crear elementos LI para cada ponente filtrado\r\n\t\t\tponentesFiltrados.forEach((ponente) => {\r\n\t\t\t\tconst ponenteHTML = document.createElement(\"LI\");\r\n\t\t\t\tponenteHTML.classList.add(\"listado-ponentes__ponente\");\r\n\t\t\t\tponenteHTML.textContent = ponente.nombre;\r\n\t\t\t\tponenteHTML.dataset.ponenteId = ponente.id;\r\n\t\t\t\tponenteHTML.addEventListener(\"click\", seleccionarPonente);\r\n\t\t\t\tlistadoPonentes.appendChild(ponenteHTML);\r\n\t\t\t});\r\n\t\t} else if (ponentesInput.value.length >= 3) {\r\n\t\t\t// Mostrar mensaje de \"no resultados\" si no hay coincidencias\r\n\t\t\tconst noResultados = document.createElement(\"P\");\r\n\t\t\tnoResultados.classList.add(\"listado-ponentes__no-resultados\");\r\n\t\t\tnoResultados.textContent = \"No hay resultados para tu búsqueda\";\r\n\t\t\tlistadoPonentes.appendChild(noResultados);\r\n\t\t}\r\n\r\n\t\t// Limpiar el valor oculto\r\n\t\tponenteHidden.value = \"\";\r\n\t};\r\n\r\n\t/**\r\n\t * Filtra los ponentes según el valor del input.\r\n\t * @param {Event} e - El evento de entrada en el input.\r\n\t */\r\n\tconst buscarPonentes = (e) => {\r\n\t\tconst busqueda = e.target.value;\r\n\t\tif (busqueda.length > 3) {\r\n\t\t\t// Normalizar y crear expresión regular para la búsqueda\r\n\t\t\tconst expresion = new RegExp(\r\n\t\t\t\tbusqueda.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\"),\r\n\t\t\t\t\"i\"\r\n\t\t\t);\r\n\t\t\tponentesFiltrados = ponentes.filter((ponente) => {\r\n\t\t\t\tconst ponenteNombre = ponente.nombre\r\n\t\t\t\t\t.normalize(\"NFD\")\r\n\t\t\t\t\t.replace(/[\\u0300-\\u036f]/g, \"\")\r\n\t\t\t\t\t.toLowerCase();\r\n\t\t\t\treturn expresion.test(ponenteNombre);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tponentesFiltrados = [];\r\n\t\t}\r\n\r\n\t\t// Mostrar los resultados filtrados\r\n\t\tmostrarPonentes();\r\n\t};\r\n\r\n\t/**\r\n\t * Formatea los datos de los ponentes para su uso en el script.\r\n\t * @param {Array} arrayPonentes - Array de objetos con datos de los ponentes.\r\n\t */\r\n\tconst formatearPonentes = (arrayPonentes = []) => {\r\n\t\tponentes = arrayPonentes.map((ponente) => ({\r\n\t\t\tnombre: `${ponente.nombre} ${ponente.apellido}`,\r\n\t\t\tid: ponente.id,\r\n\t\t}));\r\n\t};\r\n\r\n\t/**\r\n\t * Obtiene los datos de los ponentes desde la API.\r\n\t */\r\n\tconst obtenerPonentes = async () => {\r\n\t\tconst url = `/api/ponentes`;\r\n\r\n\t\ttry {\r\n\t\t\tconst respuesta = await fetch(url);\r\n\t\t\tconst resultado = await respuesta.json();\r\n\t\t\tformatearPonentes(resultado);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\"Error al obtener los ponentes:\", error);\r\n\t\t}\r\n\t};\r\n\r\n\t// Inicializa la funcionalidad si el input de ponentes existe\r\n\tif (ponentesInput) {\r\n\t\tlet ponentes = [];\r\n\t\tlet ponentesFiltrados = [];\r\n\r\n\t\tobtenerPonentes();\r\n\t\tponentesInput.addEventListener(\"input\", buscarPonentes);\r\n\t}\r\n})();\r\n","(() => {\r\n    // Selecciona el input donde se escribirán las etiquetas\r\n    const tagsInput = document.querySelector(\"#tags_input\");\r\n\r\n    // Si no existe el input, no continúa con la ejecución\r\n    if (!tagsInput) return;\r\n\r\n    // Selecciona el contenedor donde se mostrarán las etiquetas\r\n    const tagsDiv = document.querySelector(\"#tags\");\r\n    // Selecciona el input oculto para almacenar las etiquetas en formato de texto\r\n    const tagsInputHidden = document.querySelector(\"[name='tags']\");\r\n    // Inicializa el array para almacenar las etiquetas\r\n    let tags = [];\r\n\r\n    // Función para guardar la etiqueta cuando se presiona la coma\r\n    const guardarTag = (e) => {\r\n        // Verifica si la tecla presionada es la coma y si el valor del input no está vacío\r\n        if (e.key === ',' && e.target.value.trim() !== \"\") {\r\n            e.preventDefault(); // Previene el comportamiento por defecto de la tecla\r\n\r\n            const newTag = e.target.value.trim();\r\n\r\n            // Verifica si la etiqueta ya existe\r\n            if (!tags.includes(newTag)) {\r\n                // Agrega la etiqueta al array de etiquetas\r\n                tags = [...tags, newTag];\r\n                // Limpia el valor del input\r\n                e.target.value = '';\r\n                // Muestra las etiquetas actualizadas\r\n                mostrarTags();\r\n            } else {\r\n                // Opcional: informar al usuario que la etiqueta ya existe\r\n                e.target.value = '';\r\n            }\r\n        }\r\n    };\r\n\r\n    // Función para mostrar las etiquetas en el contenedor\r\n    const mostrarTags = () => {\r\n        tagsDiv.textContent = \"\"; // Limpia el contenido del contenedor\r\n\r\n        // Crea y añade cada etiqueta al contenedor\r\n        tags.forEach(tag => {\r\n            const etiqueta = document.createElement('LI'); // Crea un elemento de lista\r\n            etiqueta.classList.add('formulario__tag'); // Añade una clase CSS\r\n            etiqueta.textContent = tag; // Establece el texto de la etiqueta\r\n            etiqueta.ondblclick = eliminarTag; // Asigna el evento de doble clic para eliminar la etiqueta\r\n            etiqueta.ontouchend = eliminarTag; // Asigna el evento de finalización de toque para eliminar la etiqueta en móviles\r\n            tagsDiv.appendChild(etiqueta); // Añade la etiqueta al contenedor\r\n        });\r\n\r\n        // Actualiza el valor del input oculto con las etiquetas en formato de texto\r\n        actualizarInputHidden();\r\n    };\r\n\r\n    // Función para actualizar el valor del input oculto\r\n    const actualizarInputHidden = () => {\r\n        tagsInputHidden.value = tags.join(','); // Convierte el array de etiquetas en una cadena\r\n    };\r\n\r\n    // Función para eliminar una etiqueta al hacer doble clic o al finalizar el toque en móviles\r\n    const eliminarTag = (e) => {\r\n        const tagToRemove = e.target.textContent; // Obtiene el texto de la etiqueta a eliminar\r\n        // Filtra el array de etiquetas para eliminar la etiqueta seleccionada\r\n        tags = tags.filter(tag => tag !== tagToRemove);\r\n        // Muestra las etiquetas actualizadas\r\n        mostrarTags();\r\n    };\r\n\r\n    //Recuperar tags\r\n    if(tagsInputHidden.value !== \"\") {\r\n        tags = tagsInputHidden.value.split(\",\");\r\n        mostrarTags();\r\n    }\r\n\r\n    // Añade el evento de escucha al input para detectar la tecla presionada\r\n    tagsInput.addEventListener(\"keypress\", guardarTag);\r\n})();\r\n"]}